import { GoogleGenAI, Type } from "@google/genai";

// Initialize Gemini
// NOTE: Process.env.API_KEY is injected by the environment.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Detects watermarks in the image and returns a description.
 */
export const detectWatermarkAI = async (base64Image: string): Promise<string> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: {
        parts: [
          {
            inlineData: {
              mimeType: 'image/jpeg',
              data: base64Image
            }
          },
          {
            text: 'Analyze this image. Identify any watermarks, logos, or text overlays that spoil the image. Return a short JSON summary with keys: hasWatermark (boolean), description (string, e.g. "white text in bottom right", "company logo"), confidence (number 0-100).'
          }
        ]
      },
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
            type: Type.OBJECT,
            properties: {
                hasWatermark: { type: Type.BOOLEAN },
                description: { type: Type.STRING },
                confidence: { type: Type.NUMBER }
            }
        }
      }
    });
    return response.text || "{}";
  } catch (error) {
    console.error("Gemini Detection Error:", error);
    throw error;
  }
};

/**
 * Uses Gemini to edit the image and remove watermarks/logos.
 */
export const removeWatermarkAI = async (base64Image: string, description: string = "watermark", isMasked: boolean = false): Promise<string> => {
  try {
    let prompt;
    
    if (isMasked) {
        prompt = `The image provided has a translucent red mask painted over specific areas.
        Completely remove the objects/defects located under the red mask.
        Perform a high-definition repair (inpainting) of these areas to perfectly match the surrounding background texture, lighting, and noise profile.
        The final result must be clean, high resolution, and show no traces of the red mask or the original object. Return the cleaned image only.`;
    } else {
        prompt = `Edit this image to remove the ${description}. 
        Use a magic eraser technique to completely delete the specified object/logo/text.
        Repair the area behind it using context-aware fill to match the background texture, lighting, and details perfectly.
        Ensure no trace of the ${description} remains and the image looks original and high quality. Return the edited image only.`;
    }

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image', // Using the image optimized model
      contents: {
        parts: [
           {
            inlineData: {
              mimeType: 'image/jpeg',
              data: base64Image
            }
          },
          {
            text: prompt
          }
        ]
      },
    });

    const candidates = response.candidates;
    if (candidates && candidates.length > 0) {
        for (const part of candidates[0].content.parts) {
            if (part.inlineData) {
                return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
            }
        }
    }
    
    throw new Error("No image generated by AI");
  } catch (error) {
    console.error("Gemini Removal Error:", error);
    throw error;
  }
};

/**
 * Removes background from a logo/seal image using AI.
 */
export const removeBackgroundAI = async (base64Image: string): Promise<string> => {
  try {
    const prompt = `Edit this image to completely remove the background, making it transparent.
    Keep the main subject (logo, seal, or stamp) exactly as is, but ensure all surrounding background pixels are removed.
    The output should be a PNG with a transparent background. Return the image only.`;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
           {
            inlineData: {
              mimeType: 'image/png', // Assuming user wants png for transparency
              data: base64Image
            }
          },
          {
            text: prompt
          }
        ]
      },
    });

    const candidates = response.candidates;
    if (candidates && candidates.length > 0) {
        for (const part of candidates[0].content.parts) {
            if (part.inlineData) {
                return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
            }
        }
    }
    throw new Error("No image generated by AI");
  } catch (error) {
    console.error("Gemini Background Removal Error:", error);
    throw error;
  }
};

/**
 * Generates creative watermark text based on keywords.
 */
export const generateWatermarkTextAI = async (keywords: string): Promise<string[]> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: `Generate 5 creative, short watermark text ideas for an image based on these keywords: "${keywords}". Return a JSON array of strings.`,
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
            type: Type.ARRAY,
            items: { type: Type.STRING }
        }
      }
    });
    
    return JSON.parse(response.text || "[]");
  } catch (error) {
    console.error("Gemini Text Gen Error:", error);
    return ["Original Content", "Do Not Copy", "CleanLens AI", "Private", "Copyright 2024"];
  }
};

/**
 * Suggests watermark styling based on image analysis.
 */
export const suggestWatermarkStyleAI = async (base64Image: string): Promise<any> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: {
                parts: [
                    { inlineData: { mimeType: 'image/jpeg', data: base64Image } },
                    { text: "Analyze this image style (Bright, Dark, Busy, Minimal) and suggest optimal watermark settings: color (hex), opacity (0-100), and position (center/corner). Return JSON." }
                ]
            },
            config: {
                responseMimeType: 'application/json',
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        color: { type: Type.STRING },
                        opacity: { type: Type.NUMBER },
                        position: { type: Type.STRING }
                    }
                }
            }
        });
        return JSON.parse(response.text || "{}");
    } catch (error) {
        return { color: '#ffffff', opacity: 50, position: 'bottom-right' };
    }
}

/**
 * Suggests a Logo/Seal style based on the input text.
 */
export const suggestLogoStyleAI = async (text: string): Promise<any> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: `Act as a professional graphic designer. 
            Based on the text "${text}", suggest a logo/seal style.
            Consider the meaning (e.g. "Approved" -> Stamp, "Luxury" -> Minimal).
            
            Return JSON with:
            - shape: 'NONE' | 'CIRCLE' | 'DOUBLE_CIRCLE' | 'SQUARE' | 'ROUNDED' | 'BRACKETS'
            - color: hex string (e.g. #FF0000 for stamp, #FFFFFF for modern)
            - borderColor: hex string
            - borderWidth: number (2-10)
            - fontFamily: string (CSS font family)
            - letterSpacing: number (pixels)
            - fontWeight: '400' or '700'`,
            config: {
                responseMimeType: 'application/json',
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        shape: { type: Type.STRING },
                        color: { type: Type.STRING },
                        borderColor: { type: Type.STRING },
                        borderWidth: { type: Type.NUMBER },
                        fontFamily: { type: Type.STRING },
                        letterSpacing: { type: Type.NUMBER },
                        fontWeight: { type: Type.STRING },
                    }
                }
            }
        });
        return JSON.parse(response.text || "{}");
    } catch (error) {
        console.error("Gemini Logo Design Error:", error);
        return { shape: 'SQUARE', color: '#ffffff', borderColor: '#ffffff', borderWidth: 4 };
    }
};